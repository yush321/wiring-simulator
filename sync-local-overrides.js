#!/usr/bin/env node
"use strict";

const fs = require("fs");
const path = require("path");
const vm = require("vm");

function fail(msg) {
  console.error(`[sync-local-overrides] ${msg}`);
  process.exit(1);
}

function readText(filePath) {
  return fs.readFileSync(filePath, "utf8").replace(/^\uFEFF/, "");
}

function parseInputPayload(rawText) {
  const text = String(rawText || "").trim();
  if (!text) fail("Input file is empty.");
  try {
    return JSON.parse(text);
  } catch (_) {
    // continue
  }
  const m = text.match(/(?:let|const|var)\s+[A-Za-z_$][\w$]*\s*=\s*([\s\S]*?)\s*;?\s*$/);
  if (m && m[1]) {
    try {
      return JSON.parse(m[1]);
    } catch (_) {
      // continue
    }
  }
  try {
    return vm.runInNewContext(`(${text.replace(/;\s*$/, "")})`, {}, { timeout: 300 });
  } catch (e) {
    fail(`Failed to parse input payload: ${e.message}`);
  }
}

function parseArgs(argv) {
  const args = {
    out: "src/data/local-overrides.js",
    tutorial: null,
    numbering: null,
    answers: null,
    layout: null,
    clear: false,
    dryRun: false,
  };
  for (let i = 0; i < argv.length; i += 1) {
    const t = argv[i];
    if (t === "--out") args.out = argv[++i];
    else if (t === "--tutorial") args.tutorial = argv[++i];
    else if (t === "--numbering") args.numbering = argv[++i];
    else if (t === "--answers") args.answers = argv[++i];
    else if (t === "--layout") args.layout = argv[++i];
    else if (t === "--clear") args.clear = true;
    else if (t === "--dry-run") args.dryRun = true;
    else if (t === "--help" || t === "-h") {
      printHelp();
      process.exit(0);
    } else fail(`Unknown arg: ${t}`);
  }
  if (!args.clear && !args.tutorial && !args.numbering && !args.answers) {
    fail("At least one of --tutorial, --numbering, --answers is required (or use --clear).");
  }
  return args;
}

function printHelp() {
  console.log(
    [
      "Usage:",
      "  node sync-local-overrides.js [options]",
      "",
      "Options:",
      "  --tutorial <path>     tutorial payload",
      "  --numbering <path>    numbering payload",
      "  --answers <path>      answers payload",
      "  --layout <id>         needed for single-layout payload (e.g. stages only)",
      "  --out <path>          output js path (default: src/data/local-overrides.js)",
      "  --clear               clear all overrides",
      "  --dry-run             print summary only",
      "  -h, --help            show help",
    ].join("\n")
  );
}

function isObj(v) {
  return !!v && typeof v === "object" && !Array.isArray(v);
}

function toLayoutPatch(payload, layoutId, kind) {
  if (!isObj(payload)) fail(`${kind} payload must be an object.`);
  if (kind === "tutorial" && (Array.isArray(payload.desc) || typeof payload.title === "string")) {
    if (!layoutId) fail("Tutorial single-layout payload requires --layout <id>.");
    return { [layoutId]: payload };
  }
  if (kind === "numbering" && Array.isArray(payload.stages)) {
    if (!layoutId) fail("Numbering single-layout payload requires --layout <id>.");
    return { [layoutId]: payload };
  }
  return payload;
}

function readExistingOverrides(filePath) {
  if (!fs.existsSync(filePath)) return {};
  const text = readText(filePath);
  const sandbox = { window: { APP_DATA_OVERRIDES: {} } };
  try {
    vm.runInNewContext(text, sandbox, { timeout: 300 });
    return isObj(sandbox.window.APP_DATA_OVERRIDES) ? sandbox.window.APP_DATA_OVERRIDES : {};
  } catch (_) {
    return {};
  }
}

function writeOverrides(filePath, data) {
  const eol = "\r\n";
  const content =
    "// Auto-generated by sync-local-overrides.js" + eol +
    "window.APP_DATA_OVERRIDES = " + JSON.stringify(data, null, 2).replace(/\n/g, eol) + ";" + eol;
  fs.writeFileSync(filePath, content, "utf8");
}

function run() {
  const args = parseArgs(process.argv.slice(2));
  const outPath = path.resolve(args.out);

  let next = args.clear ? {} : readExistingOverrides(outPath);
  if (!isObj(next)) next = {};
  if (!isObj(next.tutorial)) next.tutorial = {};
  if (!isObj(next.numbering)) next.numbering = {};
  if (!isObj(next.answers)) next.answers = {};

  if (args.tutorial) {
    const payload = parseInputPayload(readText(path.resolve(args.tutorial)));
    Object.assign(next.tutorial, toLayoutPatch(payload, args.layout, "tutorial"));
  }
  if (args.numbering) {
    const payload = parseInputPayload(readText(path.resolve(args.numbering)));
    Object.assign(next.numbering, toLayoutPatch(payload, args.layout, "numbering"));
  }
  if (args.answers) {
    const payload = parseInputPayload(readText(path.resolve(args.answers)));
    if (!isObj(payload)) fail("answers payload must be an object.");
    Object.assign(next.answers, payload);
  }

  if (args.dryRun) {
    console.log("[sync-local-overrides] Dry run complete.");
    console.log(`- tutorial keys: ${Object.keys(next.tutorial || {}).length}`);
    console.log(`- numbering keys: ${Object.keys(next.numbering || {}).length}`);
    console.log(`- answers keys: ${Object.keys(next.answers || {}).length}`);
    return;
  }

  writeOverrides(outPath, next);
  console.log("[sync-local-overrides] Updated local-overrides.js");
  console.log(`- tutorial keys: ${Object.keys(next.tutorial || {}).length}`);
  console.log(`- numbering keys: ${Object.keys(next.numbering || {}).length}`);
  console.log(`- answers keys: ${Object.keys(next.answers || {}).length}`);
}

run();

